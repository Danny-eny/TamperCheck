# -*- coding: utf-8 -*-
"""TamperCheck (#build 2.5.5).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1AxxAUuagdBs5jxAtyzvuMDpqARW6Zk2q
"""

!pip install xlsxwriter

import pandas as pd
from geopy.distance import geodesic
import requests
import json

df = pd.read_csv('/content/LH - EAST BHN TAMPERING REPORT (1-20.11.2023).csv', usecols=['AssetHostID', 'AssetName2', 'DepartureDate', 'DepartureTime', 'ArrivalDate', 'ArrivalTime', 'DepartFrom', 'ArriveAt', 'StartLatLong', 'EndLatLong', 'Distance'])

# Make a backup copy of the original dataframe
df_backup = df.copy()

# Split the 'StartLatLong' and 'EndLatLong' columns
df[['StartLat', 'StartLong']] = df['StartLatLong'].str.split(' / ', expand=True)
df[['EndLat', 'EndLong']] = df['EndLatLong'].str.split(' / ', expand=True)

# Drop the original columns that are no longer needed
# Use the drop function to drop the columns
# Use the inplace=True parameter to modify the DataFrame in place
df.drop(['StartLatLong', 'EndLatLong'], axis=1, inplace=True)

#The Fix all
# Fill the NaN value in the 'DepartFrom' column with a default value
df = df.fillna('Unknown')

# Check again for NaN values in the DataFrame
nan_count = df.isna().sum()
if nan_count.any():
    print("DataFrame contains NaN values in the following columns:")
    print(nan_count[nan_count > 0])
    # Handle or fix the NaN values before proceeding

df.head()

# Define a variable for the distance threshold
distance_threshold = 10.9

#Define a function to get the distance using OSRM
def get_distance_osrm(coord1, coord2):
    # create a URL for the OSRM API
    base_url = 'http://router.project-osrm.org/route/v1/driving/'
    coordinates = f'{coord1[1]},{coord1[0]};{coord2[1]},{coord2[0]}'
    options = '?overview=false'
    url = base_url + coordinates + options

    # send a request to the OSRM API and get the response
    try:
        response = requests.get(url)
        data = response.json()
    except Exception as e:
        print(f'Error: {e}')
        return None

    # check the status code and the message of the response
    if response.status_code == 200:
        # get the distance from the response
        distance = data['routes'][0]['distance']
        # convert the distance from meters to kilometers
        distance = distance / 1000
        # return the distance
        return distance
    else:
        # print the error message
        print(f'Error: {data["message"]}')
        return None

# Define a custom function to detect tampering
def detect_tampering(group):
    global tampering_df # Use a global variable to store the tampering details

    # Compare the values of the previous and current rows
    group['TamperingDetected'] = group['ArriveAt'].shift(1) != group['DepartFrom']

    # Check if the previous row is not None
    group['TamperingDetected'] = group['TamperingDetected'] & group['ArriveAt'].shift(1).notna()

    # Calculate the distance between the coordinates of the previous and current rows using the OSRM API
    group['Distance (km)'] = group.apply(lambda row: get_distance_osrm((group['EndLat'].shift(1).loc[row.name], group['EndLong'].shift(1).loc[row.name]), (row['StartLat'], row['StartLong'])) if row['TamperingDetected'] else 0, axis=1)
    # Calculate the distance between the coordinates of the previous and current rows
    #group['Distance (km)'] = group.apply(lambda row: geodesic((group['EndLat'].shift(1).loc[row.name], group['EndLong'].shift(1).loc[row.name]), (row['StartLat'], row['StartLong'])).kilometers if row['TamperingDetected'] else 0, axis=1)

    # Filter the rows where tampering is detected and distance is greater than the threshold
    tampered_rows = group[(group['TamperingDetected']) & (group['Distance (km)'] > distance_threshold)]

    # Concatenate the tampered rows to the tampering details
    tampering_df = pd.concat([tampering_df, tampered_rows[['AssetHostID', 'DepartFrom', 'ArriveAt', 'Distance (km)']]])

    # Return the group
    return group

# Group the DataFrame by 'AssetHostID'
grouped = df.copy().groupby('AssetHostID', group_keys=True)

# Create an empty DataFrame to store the tampering details
tampering_df = pd.DataFrame(columns=['AssetHostID', 'DepartFrom', 'ArriveAt', 'Distance (km)'])

# Apply the custom function to each group
grouped = grouped.apply(detect_tampering)

# Get the tampering count from the DataFrame
tampering_count = tampering_df.shape[0]

# Print the tampering count
print("Tampering Detected:", tampering_count)
print()

# Print the tampering details
if tampering_count > 0:
    print("Tampering Details:")
    print(tampering_df)

tampering_df

#The first sheet of the excel report

#First, copy the original df
df_copy = df.copy()

# Concatenate 'StartLat' & 'StartLong' and 'EndLat' & 'EndLong' into 'StartLatLong' and 'EndLatLong'
df_copy['StartLatLong'] = df_copy['StartLat'].astype(str) + ',' + df_copy['StartLong'].astype(str)
df_copy['EndLatLong'] = df_copy['EndLat'].astype(str) + ',' + df_copy['EndLong'].astype(str)

# Drop the original columns that are no longer needed
df_copy.drop(['StartLat', 'StartLong', 'EndLat', 'EndLong'], axis=1, inplace=True)

#Rename the columns
df_copy = df_copy.rename(columns = {'AssetName2' : 'Driver'})

#Define which columns I want to use and the order
excel_columns = ['AssetHostID', 'Driver', 'DepartureDate', 'DepartureTime', 'ArrivalDate', 'ArrivalTime', 'DepartFrom', 'ArriveAt', 'StartLatLong', 'EndLatLong']

def highlight_rows(row):
  # initialize an empty list to store the styles
  styles = []
  # loop through each cell in the row
  for cell in row:
    # check if the row name (index) is in the list of indices to highlight
    if row.name in tampering_df.index:
      # append a light yellow background color to the styles list
      styles.append('background-color: yellow')
    elif row.name + 1 in tampering_df.index:
    # append a light yellow background color to the styles list (for the next row)
      styles.append('background-color: yellow')
    else:
      # append an empty string to the styles list
      styles.append('')
  # return the styles list
  return styles

# apply the highlight_rows function to the dataframe
Excel_apply = df_copy[excel_columns].style.apply(highlight_rows, axis=1)

Excel_apply

# Export the styled dataframe to the excel file
Excel_apply.to_excel('tamper_code_output.xlsx', index=False, sheet_name='TAMPERING REPORT')

#For the second sheet: SUMMARY

# Define a custom function to calculate the tampering distance for each group
def calculate_tampering_distance(group):
    # Sum the distance values of the tampered rows
    tampering_distance = tampering_details.groupby('AssetHostID')['Distance (km)'].sum()
    #Filter hopefully for [asset_group]
    #tampering_distance[tampering_distance.index.isin([asset_group])]
    # Return the tampering distance
    return tampering_distance.loc[asset_id]


#Then, create a new dataframe to store the values we'll use
summary_df = pd.DataFrame(columns=['Reg. No', 'Total Tampering Count', 'Total Tampering Distance', 'Total IVMS Distance'])

tampered_rows = grouped[(grouped['TamperingDetected']) & (grouped['Distance (km)'] > distance_threshold)]

tampering_details = tampering_df.copy()

for asset_id, asset_group in tampering_details.groupby('AssetHostID'):
    # Get the number of tampered rows for each asset ID
    total_tampering_count = asset_group['DepartFrom'].count()

    if total_tampering_count == 0:
        continue

    # Calculate total tampering distance using the custom function
    tampered_distance = calculate_tampering_distance(asset_group)
    #Test this toomorrow:
    #tampered_distance = sum(tampering_details['Distance (km)'] for asset_group in tampering_details.groupby('AssetHostID') if tampering_details['AssetHostID' == asset_id])

    # Use pandas.concat to combine the summary data
    summary_df = pd.concat([summary_df, pd.DataFrame({
        'Reg. No': [asset_id],
        'Total Tampering Count': [total_tampering_count],
        'Total Tampering Distance': [tampered_distance],
        'Total IVMS Distance': [grouped.loc[asset_id]['Distance'].sum()]
      })], ignore_index=True)


with pd.ExcelWriter('tamper_code_output.xlsx', engine='openpyxl', mode='a') as writer:
    summary_df.to_excel(writer, index=False, sheet_name='SUMMARY')

summary_df